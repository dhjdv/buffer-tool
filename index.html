<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KML Boundary Extender</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- Leaflet Geoman CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <!-- Markdown Parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .leaflet-control-zoom { border: none !important; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1) !important; }

        /* Custom Drag Handle */
        .drag-handle-icon {
            background-color: #2563eb;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: grab;
        }
        .drag-handle-icon:active {
            cursor: grabbing;
            background-color: #1d4ed8;
        }
        
        /* Center Marker Icon */
        .center-marker-icon {
            color: #ef4444;
            font-size: 16px;
            text-align: center;
            line-height: 16px;
            text-shadow: 0 0 3px white, 0 0 3px white;
            cursor: move; 
        }
        .center-marker-icon:hover {
            transform: scale(1.2);
            transition: transform 0.1s;
        }
        
        /* Tooltip Style */
        .handle-tooltip {
            background-color: #1e293b;
            border: none;
            color: white;
            font-weight: 600;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
        }
        .handle-tooltip:before { border-right-color: #1e293b; }

        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #2563eb;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #2563eb;
        }
        .toggle-label {
            width: 40px;
            height: 20px;
            background-color: #cbd5e1;
            border-radius: 9999px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s ease-in;
        }
        .toggle-label:after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s ease-in;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .toggle-checkbox:checked + .toggle-label:after {
            transform: translateX(20px);
        }
        .toggle-checkbox {
            display: none;
        }

        /* Measure Tool Styles */
        .measure-cursor { cursor: crosshair !important; }
        .cursor-tooltip {
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            color: white;
            font-size: 11px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .cursor-tooltip::before { border-right-color: rgba(30, 41, 59, 0.9); }
        
        /* Segment Labels */
        .segment-label {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid #94a3b8;
            color: #475569;
            font-size: 10px;
            font-weight: 600;
            padding: 0 4px;
            border-radius: 3px;
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .segment-label::before { border: none; }
        
        /* CUSTOM GEOMAN TOOLBAR POSITIONING */
        .leaflet-top.leaflet-right .leaflet-pm-toolbar {
            margin-top: 50px !important;  
            margin-right: 15px !important; 
            border: none !important;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05) !important;
        }
        .leaflet-pm-toolbar .leaflet-buttons-control-button {
            border: 1px solid #e2e8f0 !important;
            background-color: white !important;
            color: #475569 !important;
            width: 34px !important;
            height: 34px !important;
            line-height: 34px !important;
        }
        .leaflet-pm-toolbar .leaflet-buttons-control-button:hover {
            background-color: #f8fafc !important;
            color: #2563eb !important;
        }
        .leaflet-pm-toolbar .leaflet-buttons-control-button.active {
            background-color: #2563eb !important;
            color: white !important;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex bg-gray-100">

    <!-- Sidebar / Control Panel -->
    <div class="absolute top-4 left-4 z-[1000] w-96 max-h-[calc(100vh-2rem)] flex flex-col gap-4">
        
        <!-- Main Controls -->
        <div class="glass-panel rounded-xl shadow-2xl border border-white/20 p-6 flex flex-col gap-5 overflow-y-auto">
            <div class="flex items-center justify-between">
                <h1 class="text-xl font-bold text-slate-800 flex items-center gap-2">
                    <i class="fa-solid fa-layer-group text-blue-600"></i> GeoBuffer
                </h1>
                <span class="text-xs font-medium px-2 py-1 bg-blue-100 text-blue-700 rounded-full">Beta</span>
            </div>

            <!-- Upload Section -->
            <div id="drop-zone" class="border-2 border-dashed border-slate-300 rounded-lg p-6 text-center hover:border-blue-500 hover:bg-blue-50 transition-colors cursor-pointer group">
                <input type="file" id="file-input" accept=".kml" class="hidden">
                <div class="flex flex-col items-center gap-2">
                    <div class="w-12 h-12 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center group-hover:scale-110 transition-transform">
                        <i class="fa-solid fa-cloud-arrow-up text-xl"></i>
                    </div>
                    <p class="text-sm font-medium text-slate-600">Click or Drag KML file here</p>
                    <p class="text-xs text-slate-400">Polygons Only (Points ignored)</p>
                </div>
            </div>

            <!-- Use Demo Data Button -->
            <button id="btn-demo" class="text-xs text-blue-600 hover:text-blue-800 underline self-center -mt-2">
                Or load demo polygon
            </button>
            
            <hr class="border-slate-200">

            <!-- Buffer Controls -->
            <div class="space-y-4 opacity-50 pointer-events-none transition-opacity" id="controls-section">
                
                <!-- Buffer Direction -->
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Direction</label>
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button class="flex-1 py-1.5 text-xs font-medium rounded-md shadow-sm bg-white text-slate-800 transition-all dir-btn" data-dir="1">
                            <i class="fa-solid fa-expand-alt mr-1"></i> Expand (Out)
                        </button>
                        <button class="flex-1 py-1.5 text-xs font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all dir-btn" data-dir="-1">
                            <i class="fa-solid fa-compress-alt mr-1"></i> Shrink (In)
                        </button>
                    </div>
                </div>

                <!-- Buffer Method -->
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-2">Expansion Method</label>
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md shadow-sm bg-white text-slate-800 transition-all method-btn" data-method="buffer">
                            <i class="fa-solid fa-bullseye mr-1"></i> Standard (GIS)
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all method-btn" data-method="scale">
                            <i class="fa-solid fa-expand mr-1"></i> Same Shape
                        </button>
                    </div>
                    <!-- Dynamic Description -->
                    <p id="method-desc" class="text-[10px] mt-2 px-2 py-1 rounded border-l-2 border-blue-400 bg-blue-50 text-blue-700 leading-tight">
                        <i class='fa-solid fa-circle-check'></i> <b>Constant Distance:</b> Creates an exact uniform boundary everywhere.
                    </p>
                </div>

                <!-- GIS Sub-Options (Base Shape) -->
                <div id="gis-options-container">
                    <label class="block text-sm font-medium text-slate-700 mb-2">Base Geometry</label>
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md shadow-sm bg-white text-slate-800 transition-all base-shape-btn" data-shape="exact">
                            Exact
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all base-shape-btn" data-shape="envelope">
                            Envelope
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all base-shape-btn" data-shape="convex">
                            Hull
                        </button>
                    </div>
                    <p id="base-shape-desc" class="text-[10px] text-slate-500 mt-2 px-2 border-l-2 border-slate-300 bg-slate-50 py-1 rounded-r leading-tight">
                        Follows every curve and corner of your original shape exactly.
                    </p>
                </div>

                <!-- Scale Sub-Options (Expansion Basis) -->
                <div id="scale-options-container" class="hidden">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-sm font-medium text-slate-700">Expansion Basis</label>
                        <button id="btn-reset-center" class="text-[10px] text-blue-600 underline hover:text-blue-800 hidden" title="Reset red crosshair to true geometric center">Reset Center</button>
                    </div>
                    
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md shadow-sm bg-white text-slate-800 transition-all scale-method-btn" data-scale="factor">
                            Centroid (Factor)
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all scale-method-btn" data-scale="radial">
                            Vertex (Radial)
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all scale-method-btn" data-scale="offset">
                            Offset (Edge)
                        </button>
                    </div>
                    <p id="scale-method-desc" class="text-[10px] text-slate-500 mt-2 px-2 border-l-2 border-slate-300 bg-slate-50 py-1 rounded-r leading-tight">
                        Multiplies size based on Shape Area. Preserves exact shape angles.
                    </p>
                    <div id="center-drag-tip" class="mt-2 text-[10px] text-red-500 flex items-center gap-1 hidden">
                        <i class="fa-solid fa-crosshairs"></i> 
                        <span><b>Tip:</b> Drag the red crosshair on the map to change the expansion origin!</span>
                    </div>
                </div>

                <!-- Distance Input -->
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Distance / Expansion</label>
                    <div class="flex gap-2">
                        <input type="number" id="distance-input" value="100" class="flex-1 bg-white border border-slate-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none transition-shadow" placeholder="0">
                        <select id="unit-select" class="bg-slate-50 border border-slate-300 rounded-lg px-3 py-2 text-sm font-medium text-slate-600 focus:outline-none">
                            <option value="meters">Meters</option>
                            <option value="kilometers">Kilometers</option>
                            <option value="feet">Feet</option>
                            <option value="miles">Miles</option>
                        </select>
                    </div>
                </div>

                <!-- Slider -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-medium text-slate-500">Quick Adjust</label>
                        <span id="slider-val" class="text-xs font-bold text-blue-600">100m</span>
                    </div>
                    <input type="range" id="distance-slider" min="0" max="1000" value="100" step="10" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </div>

                <!-- Corner Style -->
                <div id="corner-style-container">
                    <label class="block text-sm font-medium text-slate-700 mb-2">Corner Style</label>
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md shadow-sm bg-white text-slate-800 transition-all join-btn" data-style="round">
                            <i class="fa-solid fa-circle-notch mr-1"></i> Round
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all join-btn" data-style="sharp">
                            <i class="fa-solid fa-play fa-rotate-270 mr-1" style="font-size: 8px;"></i> Sharp
                        </button>
                        <button class="flex-1 py-1.5 text-[10px] font-medium rounded-md text-slate-500 hover:text-slate-700 transition-all join-btn" data-style="square">
                            <i class="fa-solid fa-square-full mr-1" style="font-size: 8px;"></i> Square
                        </button>
                    </div>
                </div>

                <!-- Tools Group: Manual Editing & Measure -->
                <div class="space-y-2">
                    <!-- Manual Editing -->
                    <div class="bg-blue-50 border border-blue-100 rounded-lg p-3">
                        <div class="flex items-center justify-between mb-2">
                             <div class="flex items-center gap-2">
                                <div class="bg-white p-1.5 rounded-md shadow-sm text-blue-600">
                                    <i class="fa-solid fa-pen-to-square"></i>
                                </div>
                                <div class="flex flex-col">
                                    <span class="text-xs font-bold text-slate-700">Manual Editing</span>
                                    <span class="text-[10px] text-slate-500">Use toolbar on map ↗️</span>
                                </div>
                            </div>
                            <!-- Toggle -->
                            <div class="flex items-center">
                                <input type="checkbox" id="manual-edit-toggle" class="toggle-checkbox">
                                <label for="manual-edit-toggle" class="toggle-label"></label>
                            </div>
                        </div>
                        <div id="manual-edit-warning" class="hidden mt-2 pt-2 border-t border-blue-100 text-[10px] text-blue-600">
                            <p class="mb-1"><i class="fa-solid fa-circle-info mr-1"></i> Drag vertices to move.</p>
                        </div>
                    </div>

                    <!-- Measure Tool -->
                    <div class="bg-indigo-50 border border-indigo-100 rounded-lg p-3 transition-all duration-300" id="measure-panel">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-2">
                                <div class="bg-white p-1.5 rounded-md shadow-sm text-indigo-600">
                                    <i class="fa-solid fa-ruler-combined"></i>
                                </div>
                                <div class="flex flex-col">
                                    <span class="text-xs font-bold text-slate-700">Measure Distance</span>
                                    <span class="text-[10px] text-slate-500" id="measure-hint">Click map points</span>
                                </div>
                            </div>
                            
                            <!-- Toggle -->
                            <div class="flex items-center">
                                <input type="checkbox" id="measure-toggle" class="toggle-checkbox">
                                <label for="measure-toggle" class="toggle-label"></label>
                            </div>
                        </div>
                        
                        <!-- Measure Stats (Hidden until active) -->
                        <div id="measure-stats" class="hidden mt-3 pt-2 border-t border-indigo-100">
                            <div class="flex justify-between items-end mb-2">
                                <div class="flex flex-col">
                                    <span class="text-[10px] uppercase text-slate-400 font-bold tracking-wider">Total Distance</span>
                                    <span id="measure-total" class="text-lg font-bold text-indigo-600 leading-none">0 m</span>
                                </div>
                                <div class="flex gap-1">
                                    <button id="btn-undo-measure" class="text-xs bg-white border border-slate-200 hover:bg-slate-50 text-slate-600 px-2 py-1 rounded shadow-sm" title="Undo last point"><i class="fa-solid fa-rotate-left"></i></button>
                                    <button id="btn-clear-measure" class="text-xs bg-white border border-red-200 hover:bg-red-50 text-red-500 px-2 py-1 rounded shadow-sm" title="Clear all"><i class="fa-solid fa-trash"></i></button>
                                </div>
                            </div>
                            <div class="text-[10px] text-slate-400 flex items-center gap-1">
                                <i class="fa-solid fa-mouse-pointer"></i> <span>Right-click to finish line</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Naming Convention -->
                <div class="bg-slate-50 p-3 rounded-lg border border-slate-200">
                    <label class="block text-xs font-bold text-slate-700 mb-2">Naming Convention</label>
                    <div class="flex flex-col gap-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="name_mode" value="auto" checked class="text-blue-600 focus:ring-blue-500">
                            <span class="text-xs text-slate-600">Auto (e.g. "79m BZ")</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="name_mode" value="static100" class="text-blue-600 focus:ring-blue-500">
                            <span class="text-xs text-slate-600">Static "100m BZ"</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="name_mode" value="custom" class="text-blue-600 focus:ring-blue-500">
                            <span class="text-xs text-slate-600">Custom Prefix</span>
                        </label>
                        <input type="text" id="custom-name-input" class="w-full mt-1 px-2 py-1.5 text-xs border border-slate-300 rounded hidden" placeholder="Enter name prefix (e.g. Zone A)">
                    </div>
                </div>

                <!-- Extra Options -->
                <div>
                     <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="include-original" class="rounded text-blue-600 focus:ring-blue-500 border-gray-300">
                        <span class="text-xs font-medium text-slate-700">Include Original Geometry</span>
                    </label>
                </div>
                
                <!-- Stats (Detailed) -->
                <div class="bg-slate-50 rounded-lg p-3 border border-slate-200 space-y-3">
                    <!-- Row 1: Original -->
                    <div class="flex flex-col">
                        <span class="text-[10px] uppercase text-slate-400 font-bold tracking-wider mb-1">Original Area</span>
                        <div class="flex items-baseline gap-2">
                            <span id="original-area-ha" class="text-xs font-semibold text-slate-700">-</span>
                            <span id="original-area-sqm" class="text-[10px] text-slate-500">-</span>
                        </div>
                    </div>
                    
                    <!-- Row 2: Diff and Total -->
                    <div class="grid grid-cols-2 gap-4 border-t border-slate-200 pt-2">
                         <!-- Left: Difference -->
                         <div class="flex flex-col">
                            <span class="text-[10px] uppercase text-slate-400 font-bold tracking-wider mb-1">Added (Diff)</span>
                            <span id="diff-area-ha" class="text-sm font-bold text-green-600">-</span>
                            <span id="diff-area-sqm" class="text-[10px] text-green-600 opacity-80">-</span>
                         </div>
                         <!-- Right: Total -->
                         <div class="flex flex-col">
                            <span class="text-[10px] uppercase text-slate-400 font-bold tracking-wider mb-1">Total Area</span>
                            <span id="new-area-ha" class="text-xs font-semibold text-blue-600">-</span>
                            <span id="new-area-sqm" class="text-[10px] text-slate-500">-</span>
                         </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="pt-2 flex gap-3">
                    <button id="btn-download" class="flex-1 bg-slate-800 hover:bg-slate-900 text-white font-medium py-2.5 rounded-lg shadow-lg hover:shadow-xl transition-all flex items-center justify-center gap-2">
                        <i class="fa-solid fa-download"></i> Download KML
                    </button>
                    <button id="btn-clear" class="w-10 flex items-center justify-center bg-white border border-slate-300 text-slate-500 rounded-lg hover:bg-red-50 hover:text-red-500 hover:border-red-200 transition-colors">
                        <i class="fa-solid fa-trash"></i>
                    </button>
                </div>
            </div>
            
            <!-- Instructions/Status -->
            <div id="status-msg" class="text-xs text-center text-slate-400 mt-2">
                Ready to process
            </div>
        </div>
        
        <!-- Legend -->
        <div class="glass-panel rounded-xl shadow-lg border border-white/20 p-4 w-48 ml-auto mr-auto md:ml-0 md:mr-0 hidden" id="legend">
            <div class="flex items-center gap-2 mb-2">
                <span class="w-3 h-3 rounded-full bg-blue-500 border-2 border-white shadow-sm"></span>
                <span class="text-xs font-medium text-slate-700">Original</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="w-3 h-3 rounded-full bg-transparent border-2 border-blue-900"></span>
                <span class="text-xs font-medium text-slate-700">Buffer Zone</span>
            </div>
            <div class="mt-2 text-[10px] text-slate-400 italic text-center" id="drag-hint">
                Drag blue dot on map to resize
            </div>
        </div>
    </div>

    <!-- Map Container -->
    <div id="map" class="flex-1 h-full w-full z-0 bg-slate-200"></div>

    <!-- Libraries -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Leaflet Geoman -->
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/@mapbox/togeojson/togeojson.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 1. Map Initialization ---
            const map = L.map('map', { 
                zoomControl: false, 
                minZoom: 1, 
                maxZoom: 28 
            }).setView([20.5937, 78.9629], 5);
            L.control.zoom({ position: 'bottomright' }).addTo(map);

            const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                attribution: '© OpenStreetMap',
                maxNativeZoom: 19,
                maxZoom: 28
            });
            const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { 
                attribution: '© Esri',
                maxNativeZoom: 19,
                maxZoom: 28
            });
            const darkMatter = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxNativeZoom: 20,
                maxZoom: 28
            });
            
            satellite.addTo(map);
            L.control.layers({ "Satellite": satellite, "Street": osm, "Dark Mode": darkMatter }, null, { position: 'bottomright' }).addTo(map);
            
            // Auto-Switch to Dark Mode on High Zoom
            map.on('zoomend', () => {
                const z = map.getZoom();
                if (z > 18) { 
                    if (!map.hasLayer(darkMatter)) {
                        map.addLayer(darkMatter);
                        if (map.hasLayer(satellite)) map.removeLayer(satellite);
                        if (map.hasLayer(osm)) map.removeLayer(osm);
                    }
                } else {
                     if (map.hasLayer(darkMatter)) {
                         map.addLayer(satellite); 
                         map.removeLayer(darkMatter);
                     }
                }
            });

            // Geoman Setup with Controls
            if(map.pm) {
                map.pm.addControls({
                    position: 'topright',
                    drawCircle: false,
                    drawCircleMarker: false,
                    drawMarker: false,
                    drawPolyline: false,
                    drawRectangle: false,
                    drawPolygon: false,
                    drawText: false,
                    editMode: true,
                    dragMode: true,
                    cutPolygon: true,
                    removalMode: true,
                    rotateMode: false
                });
                
                map.pm.setGlobalOptions({ 
                    allowSelfIntersection: true,
                    snappable: true,
                    snapDistance: 15
                });
                
                // Hook into Geoman events to pause buffer updates
                map.on('pm:globaleditmodetoggled', (e) => { state.isManualEditing = e.enabled; });
                map.on('pm:globaldragmodetoggled', (e) => { state.isManualEditing = e.enabled; });
                map.on('pm:globalremovalmodetoggled', (e) => { state.isManualEditing = e.enabled; });
                map.on('pm:globalcutmodetoggled', (e) => { state.isManualEditing = e.enabled; });
            }

            // --- 2. State Management ---
            const state = {
                originalFileName: "polygon",
                originalGeoJSON: null,
                bufferedGeoJSON: null,
                bufferDistance: 100,
                bufferUnit: 'meters',
                bufferDirection: 1, // 1 for Out, -1 for In
                method: 'buffer', 
                baseShape: 'exact',
                scaleMethod: 'factor', 
                edgeStyle: 'round',
                namingMode: 'auto',
                customName: '',
                referencePoint: null,
                originalBBoxWidth: 0,
                isManualEditing: false,
                isMeasuring: false,
                featureCenters: [],
                measurePoints: [],
                isAutoRepair: true 
            };

            const layers = {
                original: L.geoJSON(null, {
                    style: { color: "#3b82f6", weight: 2, fillOpacity: 0.1, pmIgnore: true } // Ignore orig in edit
                }).addTo(map),
                buffer: L.geoJSON(null, {
                    style: { color: "#00007f", weight: 2, dashArray: '5, 5', fillOpacity: 0, fillColor: 'transparent' }
                }).addTo(map),
                handle: L.layerGroup().addTo(map),
                debug: L.layerGroup().addTo(map), 
                measure: L.layerGroup().addTo(map),
                errors: L.layerGroup().addTo(map) 
            };

            const handleIcon = L.divIcon({ className: 'drag-handle-icon', iconSize: [16, 16], iconAnchor: [8, 8] });
            const centerIcon = L.divIcon({ className: 'center-marker-icon', html: '<i class="fa-solid fa-crosshairs"></i>', iconSize: [16, 16], iconAnchor: [8, 8] });

            // --- 3. DOM Elements ---
            const els = {
                dropZone: document.getElementById('drop-zone'),
                fileInput: document.getElementById('file-input'),
                controls: document.getElementById('controls-section'),
                distanceInput: document.getElementById('distance-input'),
                distanceSlider: document.getElementById('distance-slider'),
                unitSelect: document.getElementById('unit-select'),
                dirBtns: document.querySelectorAll('.dir-btn'), 
                methodBtns: document.querySelectorAll('.method-btn'),
                methodDesc: document.getElementById('method-desc'),
                gisOptionsContainer: document.getElementById('gis-options-container'),
                baseShapeBtns: document.querySelectorAll('.base-shape-btn'),
                baseShapeDesc: document.getElementById('base-shape-desc'),
                scaleOptionsContainer: document.getElementById('scale-options-container'),
                scaleMethodBtns: document.querySelectorAll('.scale-method-btn'),
                scaleMethodDesc: document.getElementById('scale-method-desc'),
                btnResetCenter: document.getElementById('btn-reset-center'),
                centerDragTip: document.getElementById('center-drag-tip'),
                cornerContainer: document.getElementById('corner-style-container'),
                joinBtns: document.querySelectorAll('.join-btn'),
                
                // Editing
                manualEditToggle: document.getElementById('manual-edit-toggle'),
                manualEditWarning: document.getElementById('manual-edit-warning'),
                dragHint: document.getElementById('drag-hint'),
                
                // Measure Tool
                measureToggle: document.getElementById('measure-toggle'),
                measureStats: document.getElementById('measure-stats'),
                measureTotal: document.getElementById('measure-total'),
                btnUndoMeasure: document.getElementById('btn-undo-measure'),
                btnClearMeasure: document.getElementById('btn-clear-measure'),
                
                btnDownload: document.getElementById('btn-download'),
                btnClear: document.getElementById('btn-clear'),
                btnDemo: document.getElementById('btn-demo'),
                status: document.getElementById('status-msg'),
                sliderVal: document.getElementById('slider-val'),
                legend: document.getElementById('legend'),
                origHa: document.getElementById('original-area-ha'),
                origSqm: document.getElementById('original-area-sqm'),
                newHa: document.getElementById('new-area-ha'),
                newSqm: document.getElementById('new-area-sqm'),
                diffHa: document.getElementById('diff-area-ha'),
                diffSqm: document.getElementById('diff-area-sqm'),
                nameRadios: document.getElementsByName('name_mode'),
                customNameInput: document.getElementById('custom-name-input'),
                includeOriginal: document.getElementById('include-original')
            };

            // --- 4. Event Listeners ---
            els.dropZone.addEventListener('click', () => els.fileInput.click());
            els.dropZone.addEventListener('dragover', (e) => { e.preventDefault(); els.dropZone.classList.add('border-blue-500', 'bg-blue-50'); });
            els.dropZone.addEventListener('dragleave', () => { els.dropZone.classList.remove('border-blue-500', 'bg-blue-50'); });
            els.dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                els.dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                const file = e.dataTransfer.files[0];
                if (file && file.name.toLowerCase().endsWith('.kml')) processFile(file);
                else showStatus('Invalid file. Please upload a .kml file', true);
            });
            els.fileInput.addEventListener('change', (e) => { if (e.target.files[0]) processFile(e.target.files[0]); });

            els.btnDemo.addEventListener('click', loadDemoData);
            els.btnDownload.addEventListener('click', downloadCustomKML);
            els.btnClear.addEventListener('click', resetApp);
            els.btnResetCenter.addEventListener('click', () => {
                if(state.originalGeoJSON) {
                    state.featureCenters = state.originalGeoJSON.features.map(f => turf.centroid(f));
                    initCenterMarkers(); 
                    updateBuffer();
                }
            });
            
            // Direction Toggle Listener
            els.dirBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    updateToggleUI(els.dirBtns, e.currentTarget);
                    state.bufferDirection = parseInt(e.currentTarget.dataset.dir);
                    updateBuffer();
                });
            });

            els.distanceInput.addEventListener('input', (e) => {
                state.bufferDistance = parseFloat(e.target.value) || 0;
                els.distanceSlider.value = state.bufferDistance;
                updateBuffer();
            });
            els.distanceSlider.addEventListener('input', (e) => {
                state.bufferDistance = parseFloat(e.target.value);
                els.distanceInput.value = state.bufferDistance;
                updateBuffer();
            });
            els.unitSelect.addEventListener('change', (e) => {
                state.bufferUnit = e.target.value;
                syncSliderRange();
                updateBuffer();
            });

            els.methodBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    updateToggleUI(els.methodBtns, e.currentTarget);
                    state.method = e.currentTarget.dataset.method;
                    toggleMethodOptions(state.method);
                    updateBuffer();
                });
            });

            els.scaleMethodBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    updateToggleUI(els.scaleMethodBtns, e.currentTarget);
                    state.scaleMethod = e.currentTarget.dataset.scale;
                    updateScaleDescriptions(state.scaleMethod);
                    updateBuffer();
                });
            });

            els.baseShapeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    updateToggleUI(els.baseShapeBtns, e.currentTarget);
                    state.baseShape = e.currentTarget.dataset.shape;
                    updateBaseShapeDesc(state.baseShape);
                    updateBuffer();
                });
            });

            els.joinBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setCornerStyle(e.currentTarget.dataset.style);
                    updateBuffer();
                });
            });

            els.nameRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    state.namingMode = e.target.value;
                    els.customNameInput.classList.toggle('hidden', state.namingMode !== 'custom');
                });
            });
            els.customNameInput.addEventListener('input', (e) => { state.customName = e.target.value; });

            els.manualEditToggle.addEventListener('change', (e) => {
                state.isManualEditing = e.target.checked;
                if(state.isManualEditing && state.isMeasuring) {
                    state.isMeasuring = false;
                    els.measureToggle.checked = false; // Reset toggle UI
                    toggleMeasureMode();
                }
                toggleEditMode();
            });
            
            // Measure Tool
            els.measureToggle.addEventListener('change', (e) => {
                state.isMeasuring = e.target.checked;
                if(state.isMeasuring && state.isManualEditing) {
                    state.isManualEditing = false;
                    els.manualEditToggle.checked = false;
                    toggleEditMode();
                }
                toggleMeasureMode();
            });
            
            els.btnUndoMeasure.addEventListener('click', undoMeasurement);
            els.btnClearMeasure.addEventListener('click', clearMeasurements);
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && state.isMeasuring) {
                    state.isMeasuring = false;
                    els.measureToggle.checked = false;
                    toggleMeasureMode();
                }
            });

            // --- Helper Functions UI ---
            function updateToggleUI(nodeList, activeNode) {
                nodeList.forEach(b => {
                    b.classList.remove('bg-white', 'text-slate-800', 'shadow-sm');
                    b.classList.add('text-slate-500');
                });
                activeNode.classList.add('bg-white', 'text-slate-800', 'shadow-sm');
                activeNode.classList.remove('text-slate-500');
            }

            function toggleMethodOptions(method) {
                if(method === 'scale') {
                    els.gisOptionsContainer.classList.add('hidden');
                    els.scaleOptionsContainer.classList.remove('hidden'); 
                    els.methodDesc.className = "text-[10px] mt-2 px-2 py-1 rounded border-l-2 border-amber-400 bg-amber-50 text-amber-700 leading-tight";
                    els.methodDesc.innerHTML = "<i class='fa-solid fa-triangle-exclamation'></i> <b>Variable Distance:</b> Scaling preserves shape but the buffer width will vary (geometry rule).";
                    updateScaleDescriptions(state.scaleMethod);
                } else {
                    els.gisOptionsContainer.classList.remove('hidden');
                    els.cornerContainer.classList.remove('hidden');
                    els.scaleOptionsContainer.classList.add('hidden');
                    els.methodDesc.className = "text-[10px] mt-2 px-2 py-1 rounded border-l-2 border-blue-400 bg-blue-50 text-blue-700 leading-tight";
                    els.methodDesc.innerHTML = "<i class='fa-solid fa-circle-check'></i> <b>Constant Distance:</b> Creates an exact uniform boundary everywhere.";
                    layers.debug.getLayers().forEach(l => l.setOpacity(0)); 
                }
            }

            function updateScaleDescriptions(method) {
                if (method === 'factor') {
                    els.scaleMethodDesc.innerText = "Multiplies size based on Shape Area. Preserves exact shape angles.";
                    layers.debug.getLayers().forEach(l => l.setOpacity(1));
                    els.centerDragTip.classList.remove('hidden');
                    els.btnResetCenter.classList.remove('hidden');
                    els.cornerContainer.classList.add('hidden');
                } else if (method === 'radial') {
                    els.scaleMethodDesc.innerText = "Pushes corners out so edges move exactly X meters (Miter Projection).";
                    layers.debug.getLayers().forEach(l => l.setOpacity(1));
                    els.centerDragTip.classList.remove('hidden');
                    els.btnResetCenter.classList.remove('hidden');
                    els.cornerContainer.classList.add('hidden');
                } else if (method === 'offset') {
                    els.scaleMethodDesc.innerText = "Pushes boundaries outward by fixed distance (Buffer). Shape-preserving offset.";
                    layers.debug.getLayers().forEach(l => l.setOpacity(0));
                    els.centerDragTip.classList.add('hidden');
                    els.btnResetCenter.classList.add('hidden');
                    els.cornerContainer.classList.remove('hidden');
                    if (state.edgeStyle !== 'sharp') setCornerStyle('sharp');
                }
            }

            function updateBaseShapeDesc(shape) {
                if (shape === 'exact') els.baseShapeDesc.innerText = "Follows every curve and corner of your original shape exactly.";
                if (shape === 'envelope') els.baseShapeDesc.innerText = "Creates a simple rectangular box around your shape before buffering.";
                if (shape === 'convex') els.baseShapeDesc.innerText = "Wraps a rubber band around your shape, ignoring inner cavities.";
            }

            // --- CORE LOGIC ---
            function processFile(file) {
                state.originalFileName = file.name.replace('.kml', '');
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parser = new DOMParser();
                        const kml = parser.parseFromString(e.target.result, 'text/xml');
                        const kmlParser = (window.toGeoJSON || window.togeojson); 
                        const geojson = kmlParser.kml(kml);
                        const polygons = geojson.features.filter(f => f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon');
                        if (polygons.length === 0) throw new Error("No Polygons found");
                        loadGeoJSON(turf.featureCollection(polygons));
                        showStatus(`Loaded: ${file.name}`);
                    } catch (err) {
                        showStatus("Error: " + err.message, true);
                    }
                };
                reader.readAsText(file);
            }

            function loadDemoData() {
                state.originalFileName = "Demo_Polygon";
                const polygon = turf.polygon([[
                    [77.2090, 28.6139], [77.2200, 28.6139], [77.2200, 28.6250], [77.2090, 28.6250], [77.2090, 28.6139]
                ]], { name: "Demo Polygon" });
                loadGeoJSON(turf.featureCollection([polygon]));
            }

            function loadGeoJSON(geojson) {
                state.originalGeoJSON = geojson;
                state.featureCenters = geojson.features.map(f => turf.centroid(f));
                initCenterMarkers();
                els.controls.classList.remove('opacity-50', 'pointer-events-none');
                els.legend.classList.remove('hidden');
                layers.original.clearLayers();
                layers.original.addData(state.originalGeoJSON);
                const bounds = layers.original.getBounds();
                if(bounds.isValid()) map.fitBounds(bounds, { padding: [50, 50] });
                
                const firstPoly = state.originalGeoJSON.features[0];
                const coords = turf.getCoords(firstPoly);
                // Handle complex geometries for initial reference point
                let rawPt;
                if(firstPoly.geometry.type === 'MultiPolygon') {
                     rawPt = coords[0][0][0]; 
                } else {
                     rawPt = coords[0][0];
                }
                
                state.referencePoint = turf.point(rawPt);
                const center = turf.centroid(firstPoly);
                state.referenceBearing = turf.bearing(center, state.referencePoint);
                updateBuffer();
            }
            
            function initCenterMarkers() {
                layers.debug.clearLayers();
                state.featureCenters.forEach((center, index) => {
                    const latlng = [center.geometry.coordinates[1], center.geometry.coordinates[0]];
                    const marker = L.marker(latlng, { icon: centerIcon, draggable: true, title: "Drag to change expansion center" }).addTo(layers.debug);
                    if(state.method !== 'scale') marker.setOpacity(0);
                    marker.on('drag', (e) => {
                        const newLatLng = e.target.getLatLng();
                        const newCenter = turf.point([newLatLng.lng, newLatLng.lat]);
                        state.featureCenters[index] = newCenter;
                        updateBuffer();
                    });
                });
            }

            // --- MITER OFFSET HELPER ---
            function calculateMiterOffset(feature, distance) {
                const rewound = turf.rewind(feature, {reverse: false});
                const processRing = (ring) => {
                    const newRing = [];
                    const len = ring.length;
                    for(let i=0; i<len-1; i++) {
                        const curr = ring[i];
                        const prev = ring[i===0 ? len-2 : i-1];
                        const next = ring[i+1];
                        const pCurr = turf.point(curr);
                        const pPrev = turf.point(prev);
                        const pNext = turf.point(next);
                        const b1 = turf.bearing(pPrev, pCurr); 
                        const b2 = turf.bearing(pCurr, pNext); 
                        const n1 = b1 + 90;
                        const n2 = b2 + 90;
                        const rad1 = n1 * Math.PI / 180;
                        const rad2 = n2 * Math.PI / 180;
                        let bx = Math.cos(rad1) + Math.cos(rad2);
                        let by = Math.sin(rad1) + Math.sin(rad2);
                        const lenB = Math.sqrt(bx*bx + by*by);
                        if (lenB < 0.001) { bx = Math.cos(rad1); by = Math.sin(rad1); } else { bx /= lenB; by /= lenB; }
                        const dot = bx*Math.cos(rad1) + by*Math.sin(rad1);
                        let miterDist = distance;
                        if (Math.abs(dot) > 0.01) miterDist = distance / dot;
                        const limit = Math.abs(distance) * 3; // Use abs of input distance for limit magnitude
                        if (Math.abs(miterDist) > limit) miterDist = limit * Math.sign(miterDist);
                        
                        // For shrink, miterDist is negative. 
                        // To shrink using turf.destination, we use Positive Dist and Reverse Bearing?
                        // OR just rely on signed distance handling if we calculate vector manually?
                        // Turf destination requires positive distance.
                        
                        let finalDist = Math.abs(miterDist);
                        
                        // Bisector Angle
                        let bisectorBearing = Math.atan2(by, bx) * 180 / Math.PI;
                        
                        // If miterDist is negative (shrink), flip bearing 180 deg
                        if(miterDist < 0) {
                            bisectorBearing = (bisectorBearing + 180) % 360;
                        }
                        
                        const dest = turf.destination(pCurr, finalDist, bisectorBearing, {units: state.bufferUnit});
                        newRing.push(dest.geometry.coordinates);
                    }
                    newRing.push(newRing[0]); 
                    return newRing;
                };
                let newCoords = [];
                if(rewound.geometry.type === "Polygon") {
                    newCoords = rewound.geometry.coordinates.map(processRing);
                    return turf.polygon(newCoords, rewound.properties);
                } else if(rewound.geometry.type === "MultiPolygon") {
                    newCoords = rewound.geometry.coordinates.map(poly => poly.map(processRing));
                    return turf.multiPolygon(newCoords, rewound.properties);
                }
                return rewound;
            }
            
            function getDistanceInMeters(distance, unit) {
                 if(unit === 'kilometers') return distance * 1000;
                 if(unit === 'miles') return distance * 1609.34;
                 if(unit === 'feet') return distance * 0.3048;
                 return distance;
            }
            
            // --- CLEAN GEOMETRY FUNCTION ---
            function cleanGeometry(geoJSON) {
                // Always auto-repair
                let cleanFeatures = [];
                const features = geoJSON.type === 'FeatureCollection' ? geoJSON.features : [geoJSON];
                
                features.forEach(f => {
                    // Try to unkink
                    try {
                        if(f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
                            const unkinked = turf.unkinkPolygon(f);
                            cleanFeatures.push(...unkinked.features);
                        } else {
                            cleanFeatures.push(f);
                        }
                    } catch(e) {
                        console.warn("Unkink failed for feature, keeping original", e);
                        cleanFeatures.push(f);
                    }
                });
                
                return turf.featureCollection(cleanFeatures);
            }

            function updateBuffer() {
                if (!state.originalGeoJSON) return;
                try {
                    const signedDistance = state.bufferDistance * state.bufferDirection;
                    els.sliderVal.innerText = `${Math.round(state.bufferDistance)} ${getUnitAbbr(state.bufferUnit)} ${state.bufferDirection < 0 ? '(In)' : ''}`;
                    
                    let bufferedFeatures = [];
                    if (state.method === 'scale') {
                        bufferedFeatures = state.originalGeoJSON.features.map((f, i) => {
                            const center = state.featureCenters[i] || turf.centroid(f);
                            if (state.scaleMethod === 'radial') {
                                // Miter Offset supports signed distance
                                return calculateMiterOffset(f, signedDistance);
                            } else if (state.scaleMethod === 'offset') {
                                // If Sharp, use manual miter. Else use Turf (supports neg)
                                if (state.edgeStyle === 'sharp') return calculateMiterOffset(f, signedDistance);
                                let steps = 64; if (state.edgeStyle === 'square') steps = 1;
                                return turf.buffer(f, signedDistance, { units: state.bufferUnit, steps: steps });
                            } else {
                                // FIXED: Use SQRT AREA logic
                                const area = turf.area(f); 
                                const charLength = Math.sqrt(area); 
                                const distMeters = getDistanceInMeters(signedDistance, state.bufferUnit); // signed
                                
                                // Scale Factor for shrink
                                let scaleFactor = (charLength + (2 * distMeters)) / charLength;
                                if (scaleFactor < 0.001) scaleFactor = 0.001; // Clamp to point
                                
                                return turf.transformScale(f, scaleFactor, { origin: center });
                            }
                        });
                    } else {
                        layers.debug.getLayers().forEach(l => l.setOpacity(0)); 
                        const baseGeoms = state.originalGeoJSON.features.map(f => {
                            if (state.baseShape === 'envelope') return turf.bboxPolygon(turf.bbox(f));
                            if (state.baseShape === 'convex') return turf.convex(f) || f;
                            return f; 
                        });
                        let steps = 64; if (state.edgeStyle === 'sharp') steps = 3; if (state.edgeStyle === 'square') steps = 1;
                        bufferedFeatures = baseGeoms.map(geom => turf.buffer(geom, signedDistance, { units: state.bufferUnit, steps: steps }));
                    }

                    // --- INTEGRITY CHECK STEP ---
                    let rawBufferFC = turf.featureCollection(bufferedFeatures);
                    state.bufferedGeoJSON = cleanGeometry(rawBufferFC);

                    layers.buffer.clearLayers();
                    
                    // Styling for Inward
                    if (state.bufferDirection < 0) {
                         layers.original.bringToBack();
                         layers.buffer.setStyle({ 
                            color: "#00007f", 
                            weight: 2, 
                            dashArray: '5, 5', 
                            fillColor: '#ffffff', 
                            fillOpacity: 0.1 
                        });
                        layers.buffer.bringToFront();
                    } else {
                        layers.buffer.setStyle({ 
                            color: "#00007f", 
                            weight: 2, 
                            dashArray: '5, 5', 
                            fillColor: 'transparent', 
                            fillOpacity: 0 
                        });
                    }
                    
                    layers.buffer.addData(state.bufferedGeoJSON);
                    
                    if (state.isManualEditing) {
                        enableGeomanOnLayer();
                    }

                    calculateStats();
                    updateDragHandle();

                } catch (err) {
                    console.error("Buffer Error", err);
                }
            }
            
            function calculateStats() {
                if(!state.originalGeoJSON || !state.bufferedGeoJSON) return;
                const origSqM = turf.area(state.originalGeoJSON);
                const newSqM = turf.area(state.bufferedGeoJSON);
                const diffSqM = newSqM - origSqM;
                updateStatsUI(origSqM, newSqM, diffSqM);
            }

            function updateStatsUI(orig, newArea, diff) {
                const fmt = (n) => Math.round(n).toLocaleString() + " m²";
                els.origHa.innerText = toHectares(orig);
                els.origSqm.innerText = fmt(orig);
                els.newHa.innerText = toHectares(newArea);
                els.newSqm.innerText = fmt(newArea);
                
                // Visual feedback for negative
                const diffSign = diff >= 0 ? "+" : "";
                els.diffHa.innerText = diffSign + toHectares(diff);
                els.diffSqm.innerText = diffSign + fmt(diff);
                
                const colorClass = diff >= 0 ? "text-green-600" : "text-red-600";
                els.diffHa.className = `text-sm font-bold ${colorClass}`;
                els.diffSqm.className = `text-[10px] opacity-80 ${colorClass}`;
            }
            
            // --- Manual Editing & Measure (Existing) ---
            function toggleEditMode() {
                if (state.isManualEditing) {
                    layers.handle.clearLayers(); 
                    enableGeomanOnLayer();
                } else {
                    disableGeomanOnLayer();
                    updateDragHandle();
                }
            }
            function enableGeomanOnLayer() {
                layers.buffer.eachLayer(layer => {
                    layer.pm.enable({ allowSelfIntersection: true, preventMarkerRemoval: false });
                    layer.on('pm:edit', handleManualEdit);
                    layer.on('pm:dragend', handleManualEdit);
                    layer.on('pm:cut', handleManualEdit);
                    layer.on('pm:remove', handleManualEdit);
                });
            }
            function disableGeomanOnLayer() {
                layers.buffer.eachLayer(layer => {
                    layer.pm.disable();
                    layer.off('pm:edit', handleManualEdit);
                    layer.off('pm:dragend', handleManualEdit);
                });
            }
            function handleManualEdit(e) {
                const updatedGeoJSON = layers.buffer.toGeoJSON();
                state.bufferedGeoJSON = updatedGeoJSON;
                calculateStats();
            }

            // --- MEASURE TOOL (Reverted to Sidebar Logic) ---
            let tempMeasureLine = null;
            let cursorTooltip = null;
            
            function toggleMeasureMode() {
                if(state.isMeasuring) {
                    // Activate
                    els.measureStats.classList.remove('hidden');
                    map.getContainer().classList.add('measure-cursor');
                    map.on('click', handleMeasureClick);
                    map.on('mousemove', handleMeasureMove);
                    map.on('contextmenu', endMeasurement); // Right click to finish
                    els.measureTotal.innerText = "0 m";
                } else {
                    // Deactivate
                    els.measureStats.classList.add('hidden');
                    map.getContainer().classList.remove('measure-cursor');
                    map.off('click', handleMeasureClick);
                    map.off('mousemove', handleMeasureMove);
                    map.off('contextmenu', endMeasurement);
                    
                    if(cursorTooltip) {
                        cursorTooltip.remove();
                        cursorTooltip = null;
                    }
                    if(tempMeasureLine) {
                        layers.measure.removeLayer(tempMeasureLine);
                        tempMeasureLine = null;
                    }
                    clearMeasurements();
                }
            }
            
            function handleMeasureClick(e) {
                const latlng = e.latlng;
                state.measurePoints.push(latlng);
                
                L.circleMarker(latlng, {
                    color: '#4f46e5',
                    fillColor: '#fff',
                    fillOpacity: 1,
                    radius: 4,
                    weight: 2,
                    interactive: false
                }).addTo(layers.measure);
                
                if(state.measurePoints.length > 1) {
                    const prev = state.measurePoints[state.measurePoints.length - 2];
                    const dist = prev.distanceTo(latlng);
                    
                    // Add Line
                    L.polyline([prev, latlng], {
                        color: '#4f46e5', 
                        weight: 2,
                        interactive: false
                    }).addTo(layers.measure);

                    // Add Segment Label at Midpoint
                    const midLat = (prev.lat + latlng.lat) / 2;
                    const midLng = (prev.lng + latlng.lng) / 2;
                    L.tooltip({
                        permanent: true,
                        direction: 'center',
                        className: 'segment-label'
                    })
                    .setLatLng([midLat, midLng])
                    .setContent(formatDistance(dist))
                    .addTo(layers.measure);
                }
                
                updateMeasureStats();
            }
            
            function handleMeasureMove(e) {
                const currentPoint = e.latlng;
                
                if(!cursorTooltip) {
                    cursorTooltip = L.tooltip({
                        permanent: true,
                        direction: 'right',
                        offset: [15, 0],
                        className: 'cursor-tooltip'
                    }).setLatLng(currentPoint).addTo(map);
                } else {
                    cursorTooltip.setLatLng(currentPoint);
                }
                
                if(state.measurePoints.length === 0) {
                    cursorTooltip.setContent("Click to start measuring");
                    return;
                }
                
                const lastPoint = state.measurePoints[state.measurePoints.length - 1];
                const segmentDist = lastPoint.distanceTo(currentPoint);
                
                if(tempMeasureLine) {
                    tempMeasureLine.setLatLngs([lastPoint, currentPoint]);
                } else {
                    tempMeasureLine = L.polyline([lastPoint, currentPoint], {
                        color: '#6366f1', 
                        dashArray: '5, 5',
                        weight: 2,
                        opacity: 0.6,
                        interactive: false
                    }).addTo(layers.measure);
                }
                
                let totalSoFar = calculateTotalDistance() + segmentDist;
                cursorTooltip.setContent(`Total: ${formatDistance(totalSoFar)} (+${formatDistance(segmentDist)})`);
            }
            
            function calculateTotalDistance() {
                let total = 0;
                for(let i=1; i<state.measurePoints.length; i++) {
                    total += state.measurePoints[i-1].distanceTo(state.measurePoints[i]);
                }
                return total;
            }

            function updateMeasureStats() {
                const total = calculateTotalDistance();
                els.measureTotal.innerText = formatDistance(total);
            }
            
            function undoMeasurement() {
                if(state.measurePoints.length === 0) return;
                
                // Remove last point state
                state.measurePoints.pop();
                
                // Clear and redraw
                const wasTempLine = tempMeasureLine;
                const wasTooltip = cursorTooltip;
                
                layers.measure.clearLayers();
                
                // Redraw Points & Lines & Labels
                state.measurePoints.forEach((pt, i) => {
                     L.circleMarker(pt, {
                        color: '#2563eb',
                        fillColor: '#fff',
                        fillOpacity: 1,
                        radius: 4,
                        weight: 2,
                        interactive: false
                    }).addTo(layers.measure);
                    
                    if(i > 0) {
                        const prev = state.measurePoints[i-1];
                        const dist = prev.distanceTo(pt);
                        
                        L.polyline([prev, pt], {
                            color: '#2563eb', 
                            weight: 2,
                            interactive: false
                        }).addTo(layers.measure);
                        
                        // Redraw Label
                        const midLat = (prev.lat + pt.lat) / 2;
                        const midLng = (prev.lng + pt.lng) / 2;
                        L.tooltip({
                            permanent: true,
                            direction: 'center',
                            className: 'segment-label'
                        })
                        .setLatLng([midLat, midLng])
                        .setContent(formatDistance(dist))
                        .addTo(layers.measure);
                    }
                });
                
                // Restore interactive elements if active
                if(wasTempLine) {
                    tempMeasureLine = wasTempLine;
                    tempMeasureLine.addTo(layers.measure);
                }
                if(wasTooltip) {
                    cursorTooltip = wasTooltip;
                    cursorTooltip.addTo(map);
                }
                
                updateMeasureStats();
            }
            
            function endMeasurement() {
                if(tempMeasureLine) {
                    layers.measure.removeLayer(tempMeasureLine);
                    tempMeasureLine = null;
                }
                if(cursorTooltip) {
                    cursorTooltip.remove();
                    cursorTooltip = null;
                }
                map.off('mousemove', handleMeasureMove);
            }
            
            function clearMeasurements() {
                state.measurePoints = [];
                layers.measure.clearLayers();
                if(tempMeasureLine) {
                    layers.measure.removeLayer(tempMeasureLine);
                    tempMeasureLine = null;
                }
                els.measureTotal.innerText = "0 m";
                
                if(state.isMeasuring) {
                    if(cursorTooltip) cursorTooltip.setContent("Click to start measuring");
                    map.off('mousemove', handleMeasureMove);
                    map.on('mousemove', handleMeasureMove);
                }
            }
            
            function formatDistance(meters) {
                if(meters >= 1000) return (meters/1000).toFixed(2) + " km";
                return Math.round(meters) + " m";
            }
            
            function setCornerStyle(style) {
                state.edgeStyle = style;
                els.joinBtns.forEach(b => {
                    if (b.dataset.style === style) {
                        b.classList.add('bg-white', 'text-slate-800', 'shadow-sm');
                        b.classList.remove('text-slate-500');
                    } else {
                        b.classList.remove('bg-white', 'text-slate-800', 'shadow-sm');
                        b.classList.add('text-slate-500');
                    }
                });
            }

            function updateDragHandle() {
                if (state.isManualEditing) return;
                if (state.method === 'scale') {
                    if (state.scaleMethod === 'offset') {
                        // Fallthrough to show handle
                    } else {
                        layers.handle.clearLayers(); 
                        return;
                    }
                }
                
                layers.handle.clearLayers();
                if(!state.referencePoint) return;

                const handlePos = turf.destination(state.referencePoint, state.bufferDistance * state.bufferDirection, state.referenceBearing, { units: state.bufferUnit });
                const latlng = [handlePos.geometry.coordinates[1], handlePos.geometry.coordinates[0]];
                
                const marker = L.marker(latlng, { draggable: true, icon: handleIcon }).addTo(layers.handle);

                const currentLabel = `${Math.round(state.bufferDistance)}${getUnitAbbr(state.bufferUnit)}`;
                marker.bindTooltip(currentLabel, { permanent: true, direction: 'right', className: 'handle-tooltip' });

                marker.on('drag', (e) => {
                    const newLatLng = e.target.getLatLng();
                    const newPt = turf.point([newLatLng.lng, newLatLng.lat]);
                    
                    // Always calculate positive distance from reference
                    let dist = turf.distance(state.referencePoint, newPt, { units: state.bufferUnit });
                    
                    state.bufferDistance = dist;
                    els.distanceInput.value = dist.toFixed(2);
                    els.distanceSlider.value = dist;
                    els.sliderVal.innerText = `${Math.round(dist)} ${getUnitAbbr(state.bufferUnit)} ${state.bufferDirection < 0 ? '(In)' : ''}`;
                    marker.setTooltipContent(`${Math.round(dist)}${getUnitAbbr(state.bufferUnit)}`);
                });

                marker.on('dragend', () => {
                    updateBuffer();
                });
            }

            // --- Custom KML Export ---
            function downloadCustomKML() {
                if (!state.bufferedGeoJSON) return;

                const distLabel = `${Math.round(state.bufferDistance)}${getUnitAbbr(state.bufferUnit)}`;
                
                let prefix, polygonName, fileName;

                if (state.namingMode === 'custom' && state.customName.trim() !== '') {
                    const userText = state.customName.trim();
                    prefix = userText;
                    fileName = `${userText} ${state.originalFileName}`;
                    polygonName = `${userText}`; 
                } else if (state.namingMode === 'static100') {
                    prefix = `100m BZ`;
                    fileName = `${prefix} ${state.originalFileName}`;
                    polygonName = `100m BUFFERZONE`;
                } else {
                    prefix = `${distLabel} BZ`;
                    fileName = `${prefix} ${state.originalFileName}`;
                    polygonName = `${distLabel} BUFFERZONE`;
                }

                const lineColor = "ff7f0000"; 
                
                const featureToKMLGeometry = (feature) => {
                    const processRing = (ring) => ring.map(coord => `${coord[0]},${coord[1]},0`).join(" ");
                    if (feature.geometry.type === "Polygon") {
                        const outerRing = processRing(feature.geometry.coordinates[0]);
                        let innerRings = "";
                        for(let i=1; i<feature.geometry.coordinates.length; i++) {
                            innerRings += `<innerBoundaryIs><LinearRing><coordinates>${processRing(feature.geometry.coordinates[i])}</coordinates></LinearRing></innerBoundaryIs>`;
                        }
                        return `<Polygon><outerBoundaryIs><LinearRing><coordinates>${outerRing}</coordinates></LinearRing></outerBoundaryIs>${innerRings}</Polygon>`;
                    } else if (feature.geometry.type === "MultiPolygon") {
                        let mpXml = "<MultiGeometry>";
                        feature.geometry.coordinates.forEach(polyCoords => {
                            const outerRing = processRing(polyCoords[0]);
                            let innerRings = "";
                            for(let i=1; i<polyCoords.length; i++) {
                                innerRings += `<innerBoundaryIs><LinearRing><coordinates>${processRing(polyCoords[i])}</coordinates></LinearRing></innerBoundaryIs>`;
                            }
                            mpXml += `<Polygon><outerBoundaryIs><LinearRing><coordinates>${outerRing}</coordinates></LinearRing></outerBoundaryIs>${innerRings}</Polygon>`;
                        });
                        mpXml += "</MultiGeometry>";
                        return mpXml;
                    }
                    return "";
                };

                let kmlPlacemarks = "";
                
                // Aggregate all buffer features into one MultiGeometry placemark
                let multiGeomXml = "<MultiGeometry>";
                state.bufferedGeoJSON.features.forEach(feature => {
                     multiGeomXml += featureToKMLGeometry(feature).replace("<MultiGeometry>", "").replace("</MultiGeometry>", ""); 
                });
                multiGeomXml += "</MultiGeometry>";
                
                // Use a single placemark for the buffer
                kmlPlacemarks += `
                <Placemark>
                    <name>${polygonName}</name>
                    <styleUrl>#bufferStyle</styleUrl>
                    ${multiGeomXml}
                </Placemark>`;

                if (els.includeOriginal.checked && state.originalGeoJSON) {
                    const origName = `Original ${state.originalFileName}`;
                    state.originalGeoJSON.features.forEach(feature => {
                        kmlPlacemarks += `
                        <Placemark>
                            <name>${origName}</name>
                            <styleUrl>#originalStyle</styleUrl>
                            ${featureToKMLGeometry(feature)}
                        </Placemark>`;
                    });
                }

                const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
    <kml xmlns="http://www.opengis.net/kml/2.2">
    <Document>
        <Style id="bufferStyle">
        <LineStyle>
            <color>${lineColor}</color>
            <width>2</width>
        </LineStyle>
        <PolyStyle>
            <fill>0</fill>
            <outline>1</outline>
            <color>${lineColor}</color>
        </PolyStyle>
        </Style>
        <Style id="originalStyle">
        <LineStyle>
            <color>fff6823b</color>
            <width>2</width>
        </LineStyle>
        <PolyStyle>
            <fill>0</fill>
            <outline>1</outline>
        </PolyStyle>
        </Style>
        <Folder>
        <name>${fileName}</name>
        ${kmlPlacemarks}
        </Folder>
    </Document>
    </kml>`;

                const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}.kml`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            // --- Utilities ---
            function toHectares(sqMeters) {
                return (sqMeters / 10000).toFixed(4) + " HA";
            }

            function getUnitAbbr(unit) {
                const map = { meters: 'm', kilometers: 'km', feet: 'ft', miles: 'mi' };
                return map[unit] || unit;
            }

            function syncSliderRange() {
                if(state.bufferUnit === 'kilometers' || state.bufferUnit === 'miles') {
                    els.distanceSlider.max = 10;
                    els.distanceSlider.step = 0.1;
                    if(state.bufferDistance > 10) state.bufferDistance = 1;
                } else {
                    els.distanceSlider.max = 1000;
                    els.distanceSlider.step = 10;
                    if(state.bufferDistance < 10) state.bufferDistance = 100;
                }
            }

            function resetApp() {
                state.originalGeoJSON = null;
                state.bufferedGeoJSON = null;
                state.isManualEditing = false;
                els.manualEditToggle.checked = false;
                
                // Reset measure state
                state.isMeasuring = false;
                els.measureToggle.checked = false;
                els.measureStats.classList.add('hidden');
                map.getContainer().classList.remove('measuring-cursor');
                map.off('click', handleMeasureClick);
                map.off('mousemove', handleMeasureMove);
                clearMeasurements();
                
                layers.original.clearLayers();
                layers.buffer.clearLayers();
                layers.handle.clearLayers();
                layers.debug.clearLayers();
                els.controls.classList.add('opacity-50', 'pointer-events-none');
                els.legend.classList.add('hidden');
                els.fileInput.value = '';
                els.origHa.innerText = '-';
                els.origSqm.innerText = '-';
                els.newHa.innerText = '-';
                els.newSqm.innerText = '-';
                els.diffHa.innerText = '-';
                els.diffSqm.innerText = '-';
                els.customNameInput.value = '';
                showStatus("Ready to process");
                map.setView([20.5937, 78.9629], 5);
            }
            
            function showStatus(msg, isError = false) {
                els.status.innerText = msg;
                els.status.className = `text-xs text-center mt-2 ${isError ? 'text-red-500 font-bold' : 'text-slate-400'}`;
            }
        }); // End DOMContentLoaded
    </script>
</body>
</html>
